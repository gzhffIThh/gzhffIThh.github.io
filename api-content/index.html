{"posts":[{"title":"中考复习计划","content":"生物 所有的章节在2模前看5遍以上 做专题练习（重点实验） 化学 复习基础 做优加专题 物理 做压轴题 科学整理考点 英语 做中考卷 练习作文 社会 抓紧时间复习基础 做精编 ","link":"https://gzhffIThh.github.io/post/zhong-kao-fu-xi-ji-hua/"},{"title":"网络流","content":"算法笔记 算法：EK（Edmond-Karp），Dinic， ISAP 解决问题： 网络流中的最大流和费用流的求解 前置： 网络：G=(V,E)G=(V,E)G=(V,E) 是一个有限的有向图，它的每条边(u,v)∈E(u,v) \\in E(u,v)∈E都有一个非负值实数的容量c(u,v)c(u,v)c(u,v)，图中还有两个特殊节点S∈VS \\in VS∈V和T∈V(S≠T)T \\in V(S \\ne T)T∈V(S​=T)，分别为源点和汇点。 问题一：何为网络最大流？ 求一个网络中源点到汇点的最大流量。 简单来说，就是个你一个有向图，每条边上有一个容量，同时给定一个源点s和汇点t，让你求从源点到汇点的最大流量。 如果难以理解的话，可以将图想象成一个水管网，每条边为一个水管，每个水管有一个容量（超过了就会爆），想在从源点中通入无限的水，请问从汇点会流出多少水。 如果还不能理解，也可以理解为单位时间内从原点中通入无限的水，问单位时间内从汇点会流出多少水。 问题二：何为费用流？ 简单来说，就是在最大流的基础上，加一个每一边上单位流量的费用，让你求保证最大流的基础上，求出最小的费用。 问题三：何为增广路？ 就是，再找到最大流的过程中，每次找到使当前流量增加的一条路径。 解决： 1.EK（Edmond-Karp）算法 反向边 + BFS找增广路 复杂度：O(nm2)O(nm^2)O(nm2) 反向边：使程序在走过一条不是最优的增广路后可以换一条进行尝试，简单讲让程序有反悔的机会。 code：EK最大流 2.dinic算法 学习 3.ISAP（Improved Shortest Augumenting Path）算法 学习中 ","link":"https://gzhffIThh.github.io/post/wang-luo-liu/"},{"title":"凸包学习","content":"凸包学习 概念 向量: 有方向的量 如从A(x1,y2)A(x_1, y_2)A(x1​,y2​)到B(x2,y2)B(x_2, y_2)B(x2​,y2​)的向量表示为AB→=(x1−x2,y1−y2)\\overrightarrow{AB}=(x_1-x_2,y_1-y_2)AB=(x1​−x2​,y1​−y2​) 点积: A在B所在方向的投影的模长和B的模长的乘积,来可以判两个向量是否垂直 如:OA→=(x1,y1),OB→=(x2,y2)\\overrightarrow{OA}=(x_1,y_1),\\overrightarrow{OB}=(x_2,y_2)OA=(x1​,y1​),OB=(x2​,y2​) OA→⋅OB→=(x1−x2,y1−y2)\\overrightarrow{OA}\\cdot{\\overrightarrow{OB}}=(x_1-x_2, y_1-y_2)OA⋅OB=(x1​−x2​,y1​−y2​) 叉积: OA→⋅OB→=x1y2−x2y1\\overrightarrow{OA}\\cdot{\\overrightarrow{OB}}=x_1y_2-x_2y_1OA⋅OB=x1​y2​−x2​y1​ 是个向量，但垂直于平面，当做标量就行了。 用途:判断顺逆时针 解决 凸包:最小的凸多边形覆盖所有点 求法1:将坐标中的点按x−yx-yx−y排序，并用栈维护一条凸边，每到一个点，用叉积判断栈首3个元素是否会形成凹边，形成则出栈，否则就入栈。 从左下到右上计算下半凸包，再从左下到右上计算上半凸包，合并即可。 P2742 code 求法2:极角排序 ","link":"https://gzhffIThh.github.io/post/tu-bao-xue-xi/"},{"title":"BFS心得","content":"一、BFS思想 1. 保存每个状态（当前坐标，步数等），从每个有效状态进行“分身”，并再保存每个分身状态。。。直到到目标状态（坐标，目标图，变量数值等） 2.DFS 和 BFS区别： DFS：先尝试一种情况一直到不能再进行了，回溯到上一个情况再换一个尝试 BFS: 将当前可行的情况都保存，在分别进行拓展 3.解决的问题（要求搜索的问题中只有相邻的状态有关系）： （1）最少花费、步数 由于其以层数增长，每种状态只保存一次，第一次到目标状态时就是最快的速度。 P1135 奇怪的电梯 P1443 马的遍历 （2）图的染色(遍历） 二、实现方法 1.记录状态 -&gt;结构体（打包） struct point { int x, y;//最常用 //坐标位置 int no;//某种编号 int step//记录步数、花费等 int x//记录当前的某种信息 } s, t; // s -&gt; 起始状态 // t -&gt; 目标状态 2.保存当前的有效状态-&gt;队列 (1)STL ..(queue) queue&lt;point&gt; Q; //创建了一个命名为Q的队列 //队列中的数据类型为point（结构体） //基本操作 Q.push(s); //将起始状态入队 Q.push(v); //将有效状态入队 Q.pop(); //将队列中第一个元素弹出 Q.front(); // 队列的第一个元素 (2)数组模拟队列 struct point q[10014];//q数组 int f = 1, e = 1;//f -&gt; 队首指针 //e -&gt; 队尾指针 q[1] = s; //将起始状态入队 q[++e] = v; //将有效状态入队 f++; //将队列中第一个元素删去 q[f] // 队列的第一个元素 3.哈希判重 (1)直接以当前位置哈希 bool used[x][y]; bool used[node]; (2)状压二进制(当数组哈希位数不够用时) 以P4011 孤岛营救问题 为例 bool used[key][x][y]；//用二进制存钥匙 //二进制第i位为1 -&gt;有编号为i的钥匙 //为0没有 //使用&gt;&gt; 和 &lt;&lt; 检测某位有无钥匙 (3）对大质数求余 ","link":"https://gzhffIThh.github.io/post/bfs-xin-de/"},{"title":"190806 noip模拟赛","content":"这次模拟赛T1当时未想到。。。T3难一点 score：213 T1 数字游戏 【问题描述】 大家列队后，都觉得累了，于是一起坐到院子中的草地上休息。这时Anna突然想跟她的最大竞争对手Cici玩一个数字游戏，她要你编写程序帮助她取得胜利。 第i次游戏初始时有一个整数N_i(1 &lt;= N_i &lt;= 1,000,000)，，游戏以Anna先开始,然后是Cici，这样两人轮流进行。在每一轮中，一个游戏者可以把当前整数中减去原整数中最大的数字或最小的非零数字，形成一个新的整数。例如从3014开始，我们可以减去1或4，分别形成整数3013或 3010. 直到这个整数变为0时游戏结束。游戏结束时最后轮到那人就是胜利者。 Anna和Cici总共进行G(1 &lt;= G &lt;= 100)次游戏。请你帮助确定每次游戏到底是Anna还是Cici获得胜利。Anna和Cici两人都是足够聪明的，如果轮到某人时，对方留给她的数是必胜的，她将毫不犹豫按最优策略取得胜利。 假如某次游戏N_i=13。Anna先走并从中减去3，剩下10，然后Cici只能减去1，剩下9，Anna减去9，剩下0游戏结束，Anna取得这次游戏的胜利。 【输入格式】 * 第1行：一个整数G * 第2..G+1行: 第i+1行包含一个整数: N_i 【输出格式】 * 第1..G行: 第i行包含&quot;YES&quot; ，表示Anna取得第i次游戏的胜利，否则为&quot;NO&quot;。 【输入样例】cdgame.in 2 9 10 【输出样例】cdgame.out YES NO 第一题是简单的博弈论，对于一个数，若它的后继状态均先手必胜，则当前必败；反之，必胜。 用f[i]表示i这个数字先手情况 1表示必胜，0表示必败 #include &lt;bits/stdc++.h&gt; using namespace std; inline int read() { int f = 1, a = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0'){if(c == '-') f = -f;c = getchar();} while(c &lt;= '9' &amp;&amp; c &gt;= '0'){a = a * 10 + c - '0';c = getchar();} return a * f; } int t; int n; int f[1000005]; int minx(int x) { int d = x, m = 9; while(d &gt; 0) { if(d % 10 != 0) m = min(m, d % 10); d /= 10; } return x - m; } int maxx(int x) { int d = x, m = 0; while(d &gt; 0) { m = max(m, d % 10); d /= 10; } return x - m; } int main() { t = read(); f[0] = 0; for (int i = 1; i &lt;= 1000000; i++) { if(f[minx(i)] == 1 &amp;&amp; f[maxx(i)] == 1) f[i] = 0; else f[i] = 1; } while(t--) { n = read(); if(f[n] == 1) cout &lt;&lt; &quot;YES\\n&quot;; else cout &lt;&lt; &quot;NO\\n&quot;; } return 0; } T2 电话时间 【问题描述】 某人总是花很多时间给父母打电话。有一次他记录了打电话的开始时间和结束时刻t1和t2，请你帮他算算此次通话一共用了多少秒。又有一次，他记录了打电话的开始时刻t1和通话的时间长度len，请你帮他计算他在什么时刻结束通话。 已知每次通话时间小于24个小时。 【输入文件】 输入文件phone.in的第一行为一个正整数T，表示了数据组数。 接下来T行，每行第一个数为k： 如果k = 0，接下来包含两个时间t1和t2，表示了打电话的开始时间和结束时刻，用一个空格隔开，时间格式为HH:MM:SS，其中0≤HH≤23,0≤MM,SS≤59。HH、MM和SS都是两位数字，因此0:1:2是不合法的时间（应写作00:01:02）。你应该对这个询问输出通话时间长度，答案一定为区间[0,86400)之内的非负整数。 如果k = 1，接下来包含一个时间t1和一个非负整数len，表示了打电话的开始时刻与通话时间长度，用一个空格隔开，时间格式同为HH:MM:SS，同样时间小于24个小时，即len&lt;86400。你应该对这个询问输出结束通话的时刻，同为HH:MM:SS格式。 【输出文件】 输出文件phone.out包含T个整数或者时间，对于每个询问输出对应的答案。 【样例输入】 4 0 01:02:03 04:05:06 0 23:59:59 00:00:00 1 00:00:03 3 1 23:59:58 4 【样例输出】 10983 1 00:00:06 00:00:02 【数据规模与约定】 对于20%的数据，T ≤ 10； 对于40%的数据，T ≤ 100； 对于100%的数据，T ≤ 100 简单的模拟 注意过夜的情况 #include &lt;bits/stdc++.h&gt; using namespace std; #define ll long long inline ll read() { int f = 1, a = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0'){if(c == '-') f = -f;c = getchar();} while(c &lt;= '9' &amp;&amp; c &gt;= '0'){a = a * 10 + c - '0';c = getchar();} return a * f; } ll T, s1, s2, s3, t1, t2, t3, tmps, tmpt, len, k; int main() { /// freopen(&quot;phone.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;phone.out&quot;, &quot;w&quot;, stdout); T = read(); while(T--) { k = read(); if(k == 0) { s1 = read(), s2 = read(), s3 = read(); t1 = read(), t2 = read(), t3 = read(); tmps = s1 * 60 * 60 + s2 * 60 + s3; tmpt = t1 * 60 * 60 + t2 * 60 + t3; if(tmpt &lt; tmps) tmpt += 86400; printf(&quot;%lld\\n&quot;, tmpt - tmps); } if(k == 1) { s1 = read(), s2 = read(), s3 = read();len = read(); tmps = (s1 * 60 * 60 + s2 * 60 + s3 + len) % 86400; t1 = tmps / 3600, t2 = (tmps % 3600) / 60, t3 = tmps % 60; if(t1 &lt; 10) printf(&quot;0%lld:&quot;, t1); else printf(&quot;%lld:&quot;, t1); if(t2 &lt; 10) printf(&quot;0%lld:&quot;, t2); else printf(&quot;%lld:&quot;, t2); if(t3 &lt; 10) printf(&quot;0%lld\\n&quot;, t3); else printf(&quot;%lld\\n&quot;, t3); } } return 0; } T3 min 【题目描述】 给定N个数，请你选出两段连续的数，满足每段的长度都不超过L，两段之间 不相交，且选出的数和最大。 【输入文件】 第一行 N L 输出文件 最大的和 【样例输入】 9 3 1 3 -1 3 -3 3 -1 3 1 【样例输出】 10 【数据约定】 33%：N,L&lt;=1000 66%：N,L&lt;=100000 100%：N,L&lt;=1000000 想法一：O(n^4) 暴力枚举 -&gt; TLE 想法二：两遍从左到右的单调队列找最值 -&gt;不一定正确（可能一开始的最大区间分开成两边的两个区间更优） 正解: f[i] 表示 从前到i为止的最大连续区间 ， g[i]表示 从后到i为止的最大连续区间 再O(n)枚举 F[i] + G[i + 1] 的max #include &lt;bits/stdc++.h&gt; using namespace std; #define fu(i, l, r) for(int i = l; i &lt;= r; i++) #define fd(i, l, r) for(int i = l; i &gt;= r; i--) #define ll long long #define N 2000005 #define M 1000005 inline int read() { int f = 1, a = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0'){ if(c == '-')f = -f; c = getchar(); } while(c &lt;= '9' &amp;&amp; c &gt;= '0'){ a = a * 10 + c - '0'; c = getchar(); } return a * f; } int n, l; int a[N]; int sum[N], h[N], h2[N], f[N], d[N]; int q[N], b = 1, r = 0; int ans = -314324124; int main() { n = read(); l = read(); fu(i, 1, n) a[i] = read(); fu(i, 1, n) sum[i] = sum[i - 1] + a[i]; fu(i, 1, n) { while(b &lt;= r &amp;&amp; i - q[b] &gt; l) b++; while(b &lt;= r &amp;&amp; sum[i - 1] &lt;= sum[q[r]]) r--; q[++r] = i - 1; h[i] = sum[i] - sum[q[b]]; f[i] = max(f[i - 1], h[i]); } b = 1, r = 0; fd(i, n, 1) { while(b &lt;= r &amp;&amp; q[b] - i + 1 &gt; l) b++; while(b &lt;= r &amp;&amp; sum[i] &gt;= sum[q[r]]) r--; q[++r] = i; h2[i] = sum[q[b]] - sum[i - 1]; d[i] = max(d[i + 1], h2[i]); } fu(i, 1, n - 1) ans = max(ans, f[i] + d[i + 1]); printf(&quot;%d&quot;, ans); return 0; } T4 圣诞岛的旅行 时间限制 1s 【问题背景】 Angel喜欢无目的的乱逛，当然，他不会轻易地回头。Angel想去广场，那么，他什么时候才能到呢？ 【问题描述】 Angel已经买了一份圣诞岛的地图，地图上有N(N &lt;= 100)个交叉路口，交叉路口之间有马路相连接(不超过1000条马路)。 因为圣诞岛的人遵循奇怪的规则，道路都是单向的，不同的道路之间有一定的距离，我们假设Angel所在的地点为点1，广场所在点为N。 假设Angel走一单位距离需要一单位时间。 问Angel最早和最迟什么时候到达广场？ 【输入格式】 第一行为N, M，N是路口的数量，M是马路的数量。 后M行，每行3个整数X, Y, Weight，代表一条从X路口到Y路口，长度为Weight的马路。 【输出格式】 对于每组数据，第一行请输出最少时间，第二行请输出最迟时间，要是可怜的Angel永远到不了广场，那就只要输出“Never”。 【样例数据】 Input 5 5 1 2 1 1 4 10 2 3 1 3 4 1 4 5 1 Output 4 11 简单的图论（最长路 + 最短路） #include &lt;bits/stdc++.h&gt; using namespace std; inline int read() { int f = 1, a = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0'){if(c == '-') f = -f;c = getchar();} while(c &lt;= '9' &amp;&amp; c &gt;= '0'){a = a * 10 + c - '0';c = getchar();} return a * f; } int n, m; int head[105], nxt[1005], v[1005], w[1005], cnt; void add(int x, int y, int z) { nxt[++cnt] = head[x]; head[x] = cnt; v[cnt] = y; w[cnt] = z; } int q[1000005], inq[105], f = 1, e = 0, dis[1005]; int main() { // freopen(&quot;travel.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;travel.out&quot;, &quot;w&quot;, stdout); n = read();m = read(); for (int i = 1; i &lt;= m; i++) { int x = read(), y = read(), z = read(); add(x, y, z);} memset(dis, 20, sizeof(dis)); dis[1] = 0, inq[1] = 1, q[++e] = 1; while(f &lt;= e) { int _u = q[f++]; for (int i = head[_u]; i != 0; i = nxt[i]) { int _v = v[i]; if(dis[_v] &gt; dis[_u] + w[i]) { dis[_v] = dis[_u] + w[i]; if(inq[_v] == 0) { inq[_v] = 1; q[++e] = _v; } } } inq[_u] = 0; } if(dis[n] == 336860180) { cout &lt;&lt; &quot;Never&quot;; return 0; } cout &lt;&lt; dis[n] &lt;&lt; endl; memset(dis, 20, sizeof(dis)); dis[1] = 0, inq[1] = 1, e = 0, f = 1, q[++e] = 1; while(f &lt;= e) { int _u = q[f++]; for (int i = head[_u]; i != 0; i = nxt[i]) { int _v = v[i]; if(dis[_v] &gt; dis[_u] - w[i]) { dis[_v] = dis[_u] - w[i]; if(inq[_v] == 0) { inq[_v] = 1; q[++e] = _v; } } } inq[_u] = 0; } cout &lt;&lt; -dis[n]; return 0; } ","link":"https://gzhffIThh.github.io/post/190806-noip-mo-ni-sai/"},{"title":"190809noip模拟赛","content":"很正常的一场模拟 score:300 T1 素数 【问题描述】 给定一个正整数N，询问1到N中有多少个素数。 ####【输入格式】primenum.in 一个正整数N。 【输出格式】primenum.out 一个数Ans，表示1到N中有多少个素数。 【输入样例】 10 【输出样例】 4 【数据规模】 30% N&lt;=100 70% N&lt;=5000 100% N&lt;=10000000 签到题？ 用欧拉筛O(n)搞定 #include &lt;bits/stdc++.h&gt; using namespace std; inline int read() { int f = 1, a = 0;char c = getchar(); while(c &gt; '9' || c &lt; '0'){ if(c == '-') f = -f; c = getchar(); } while(c &lt;= '9' &amp;&amp; c &gt;= '0'){ a = a * 10 + c - '0'; c = getchar(); } return a * f; } int n, len = 0; const int maxn = 1e8 + 5; int p[maxn]; bool used[maxn]; int main() { // freopen(&quot;primenum.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;primenum.out&quot;, &quot;w&quot;, stdout); n = read(); for (int i = 2; i &lt;= n; i++) { if(!used[i]) p[++len] = i; for (int j = 1; j &lt;= len &amp;&amp; i * p[j] &lt;= n; j++) { used[i * p[j]] = 1; if(i % p[j] == 0) break; } } printf(&quot;%d&quot;, len); return 0; } T2 传玫瑰 【题目描述】 情人节到了，情侣们也活跃起来了。这不，GoldenSun和Yoyo_Yao分到了同一个班上（真有缘）。这天，GoldenSun专门跑到了花店，为Yoyo_Yao选了999支玫瑰花（-_-|||），可当GoldenSun说了一大堆肉麻的话，正准备把花送给Yoyo_Yao时，班主任DuBowen进来了，无奈的GoldenSun只得从自己的位子上把花传给Yoyo_Yao。如果一整束传，不但比较抢眼，说不定还会被中途的一些八卦的人抢走，所以GoldenSun只能一支一支的传。 已知GoldenSun他们班的座位是一个矩形，GoldenSun的位子在(x,m)，Yoyo_Yao的位子在(y,n)，传玫瑰时，只能纵横传而不能斜传（更不能扔）。又知GoldenSun班上的同学很八卦，每经过一个同学传时，玫瑰花就会扣去一定的成长值（玫瑰先开始有个成长值），即那个同学的八卦度，当玫瑰的成长值不大于0时，玫瑰就会凋零。GoldenSun希望自己的心血不要白费，即所有的玫瑰花都能传到Yoyo_Yao手中，所以如果有这种情况，GoldenSun就会自己冒着风险送这朵玫瑰。 请你帮GoldenSun找到一条令玫瑰成长值为最高的路线，让GoldenSun能向Yoyo_Yao在情人节之际表达自己的爱意。 【输入格式】 输入第一行有2个用空格隔开的整数a和b，表示班里有a行b列（1&lt;=a,b&lt;=90）。 第二行有四个用空格隔开的整数x,m,y,n，(x,m)为GoldenSun的座位，(y,n)为Yoyo_Yao的座位。（1&lt;=x,y&lt;=a;1&lt;=m,n&lt;=b） 第三行有一个整数love为单支玫瑰的最初成长值。(0&lt;love&lt;=maxlongint) 来的a行是一个a*b的矩阵，矩阵中第i行j列的正整数表示坐在第i行j列的学生的八卦程度，每行的b个整数之间用空格隔开。（当然他们两个人的八卦程度为0） 八卦程度(0&lt;=bg&lt;=love) 【输出格式】 输出共一行，包含一个整数，表示单支玫瑰最后成长值的最大值。 如果是GoldenSun自己送，则输出love，即单支玫瑰的最初成长值。 【输入样例】 2 2 1 1 2 2 3 0 1 1 0 【输出样例】 2 看起来像传纸条 然而正解是最短路？？？ #include &lt;bits/stdc++.h&gt; using namespace std; #define ll long long inline ll read() { int f = 1, a = 0;char c = getchar(); while(c &gt; '9' || c &lt; '0'){ if(c == '-') f = -f; c = getchar(); } while(c &lt;= '9' &amp;&amp; c &gt;= '0'){ a = a * 10 + c - '0'; c = getchar(); } return a * f; } ll n, m; ll sx, sy, tx, ty, lo; ll g[105][105]; ll dis[105][105], f = 1, e = 0; bool inq[105][105]; struct point { int x, y; } q[400005]; ll det[4][2] = { {0, 1}, {1, 0}, {-1, 0}, {0, -1} }; int main() { //freopen(&quot;sendrose.in&quot;, &quot;r&quot;, stdin); //freopen(&quot;sendrose.out&quot;, &quot;w&quot;, stdout); n = read();m = read(); sx = read();sy = read();tx = read();ty = read();lo = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) g[i][j] = read(); memset(dis, 20, sizeof(dis)); dis[sx][sy] = 0, inq[sx][sy] = 1, q[++e].x = sx, q[e].y = sy; while(f &lt;= e) { point u = q[f++]; for (int i = 0; i &lt; 4; i++) { point v = u; v.x += det[i][0]; v.y += det[i][1]; if(v.x &lt; 1 || v.x &gt; n || v.y &lt; 1 || v.y &gt; m) continue; if(dis[v.x][v.y] &gt; dis[u.x][u.y] + g[v.x][v.y]) { dis[v.x][v.y] = dis[u.x][u.y] + g[v.x][v.y]; if(inq[v.x][v.y] == 0) { inq[v.x][v.y] = 1; q[++e].x = v.x; q[e].y = v.y; } } } inq[u.x][u.y] = 0; } printf(&quot;%lld&quot;, lo - dis[tx][ty] &lt; 0 ? lo : lo - dis[tx][ty]); return 0; } T3 一起去打cs 【问题描述】 早就和lyk约好了去打cs，一直没找着时间，终于今天我家没人，他家也没人，总算可以出去了。但是偏偏天公不作美，某某人非要留那么多题要做。没办法只能尽快做完然后抓紧时间吧…… 为了尽量节省时间，我俩决定分开做所有题吧（嘿嘿，稍微耍一下滑~~）。但是有的题我比较擅长，而有的题lyk要比我做的快。所以为了尽快做完所有的题，我们要好好的分配一下。现在给出你要做题 的数目和我俩分别做每个题所需要的时间。希望你帮忙计算一下，我们最少需要多长时间才能做完所有的题去打cs啊！！！ 【输入格式】cs.in 第一行一个正整数n，表示有n个题要做。 接下来有n行，每行两个正整数ai，bi。 分别表示我和lyk做每个题所用的时间。 【输出格式】cs.out 一个数，最少需要多长时间才能去打CS。 【输入样例】 3 5 10 6 11 7 12 【输出样例】 12 【输入输出样例解释】 我完成题目1和题目2，时间为11。lyk完成题目3，时间为12。 或者 我完成题目1和题目3，时间为12。lyk完成题目2，时间为11。 【数据规模】 30%的数据满足：1 &lt;= n &lt;= 20 100%的数据满足：1 &lt;= n &lt;= 200 , 1 &lt;= ai,bi &lt;=200 非常简单的动态规划。 题目类型：独立任务最优调度问题 状态设计：f[i,j]表示前i个任务，第一个人用了j时间，第二个人所用最小时间 转移方程：f[i,j]=min{f[i-1,j-a[i]],f[i-1,j]+b[i]} #include &lt;bits/stdc++.h&gt; using namespace std; int n, a[201], b[201]; int f[201][40001]; int ans = 10000000; int sum = 0; int main() { // freopen(&quot;cs.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;cs.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]), sum += a[i]; memset(f, 11, sizeof(f)); memset(f[0], 0, sizeof(f[0])); for (int i = 0; i &lt; n; i++) for (int j = sum - a[i + 1]; j &gt;= 0; j--) { f[i + 1][j + a[i + 1]] = min(f[i + 1][j + a[i + 1]], f[i][j]); f[i + 1][j] = min(f[i + 1][j], f[i][j] + b[i + 1]); } for (int j = 0; j &lt;= sum; j++) ans = min(max(f[n][j], j), ans); printf(&quot;%d&quot;, ans); return 0; } T4 战争 ####【问题描述】 在2240年，一场巨大的战争在地球联合力量（EAF）与火星联盟(MF)之间展开。至今，双方势均力敌。因最近的一次经济危机，资源紧缺，EAF将被MF勒要更多领土。为此，EAF决定采取战争以来最重要的行动：发动对分散在MF上各处的基地进行同时攻击。EAF的力量大都是mechs——大型两足跛行车，有飞行功能。 典型的MF基地概况如下：构成基地的房屋地跨一到两块领土。每块领土被保护塔产生的穿不透的能量层所笼罩，以免于外来袭击。这些保护塔围绕在领土周围起保护作用。 每座保护塔通过建造在地面上的水道与至少一座塔相联系。当那些相联系的塔围成一圈，它们产生能量层。否则能量层消失。 MF知道如果能量层消失，基地将很容易被EAF的力量侵占，因此，被水道相连的两座塔保护水道免受军事袭击。每座塔有防御功能，能拆卸指定数量的mechs，每个水道在坍塌之前能解决特定数量敌方mechs的袭击。这个数量由水道连接的两塔能拆卸的总数量决定。两座塔不能被一个以上的水道相连。 但是，袭击塔一边的水道不减少塔在另一边能拆卸的mechs的数量。因为这次行动是突袭，所有的对水道的袭击都必须同时，所有水道同时坍塌瓦解。 所有能量层必须废除才算毁灭了一个MF基地。破坏所有水道能达此目的，但也将需要很多mechs 牺牲。EAF只有很少的力量花费了，必须最有效率地部署mechs。 你被赋予这任务，写程序：使EAF胜利。给定一幅保护塔的曲线图，决定哪些水道要被破坏，来使所有能量层消失，要求战斗中牺牲最少的mechs。 【输入格式】 第一行为一个整数m，2 &lt; m &lt;= 100，代表塔的数量。 以下2m行，对于每个塔都有两行输入： ◎一行包含三个正整数i(0 &lt;= i &lt;= m-1)，ui(1 &lt;= ui &lt;= 50)，ci(1 &lt;= ci &lt;= m-1)：每个塔的身份标识、可以摧毁的mechs的数量和与它相连的河道的数量。两个整数间用一个空格隔开。 ◎一行包含ci个不同的正整数，代表和塔i连接的塔。一个塔不能连接到它自己，两个整数间用一个空格隔开。 该防御体系至少能够生成一个能量层。 不一定所有的塔连通。 【输出格式】 一行一个整数，代表EAF摧毁所有能量层所需要消耗的最少数量的mechs。 【输入样例】 3 0 1 2 1 2 1 2 2 0 2 2 3 2 0 1 【输出样例】 3 总结题意，就是花最少的费用把一个有环的图拆成一个无环的图，无环的图 是什么，很显然是树，要花最少的费用把图拆成树即保留权值最大的树，推 到这里我想大家应该知道这题的算法了，就是最大生成树 这里用的是prim #include &lt;bits/stdc++.h&gt; using namespace std; inline int read() { int f = 1, a = 0;char c = getchar(); while(c &gt; '9' || c &lt; '0'){ if(c == '-') f = -f; c = getchar(); } while(c &lt;= '9' &amp;&amp; c &gt;= '0'){ a = a * 10 + c - '0'; c = getchar(); } return a * f; } int n, a[105], to[105][105]; struct edge { int u, v, w; } e[20005]; int tmp[105]; int cnt = 0; bool used[105][105]; bool cmp(edge a, edge b) { return a.w &gt; b.w; } int fa[105]; int find(int x) { if(fa[x] != x) fa[x] = find(fa[x]); return fa[x]; } int ans, sum; int x; int main() { // freopen(&quot;warfare.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;warfare.out&quot;, &quot;w&quot;, stdout); n = read(); for (int i = 1; i &lt;= n; i++) { x = read(); a[x] = read(); tmp[x] = read(); for (int j = 1; j &lt;= tmp[x]; j++) to[x][j] = read(); } for (int i = 0; i &lt; n; i++) for (int j = 1; j &lt;= tmp[i]; j++) if(used[i][to[i][j]] == 0) { e[++cnt].u = i; e[cnt].v = to[i][j]; e[cnt].w = a[i] + a[to[i][j]]; sum += e[cnt].w; used[i][to[i][j]] = 1; used[to[i][j]][i] = 1; } sort(e + 1, e + cnt + 1, cmp); for (int i = 1; i &lt;= n; i++) fa[i] = i; for (int i = 1; i &lt;= cnt; i++) { if(find(e[i].u) == find(e[i].v)) continue; else { int uu = find(e[i].u);int vv = find(e[i].v); ans += e[i].w; fa[uu] = vv; } } printf(&quot;%d&quot;, sum - ans); return 0; } ","link":"https://gzhffIThh.github.io/post/190809noip-mo-ni-sai/"},{"title":"历年noip普及组考点分析","content":" 2019 csp前夕 2018 1. 标题统计 简单的字符串题， 读入统计即可 2. 龙虎斗 简单的模拟题， 要开longlong 3. 摆渡车 dp， 要各种优化（范围） 4. 对称二叉树 爆搜即可， 对称让指针一左一右跳去判定 2017 1. 成绩 简单题 2. 图书管理员 简单模拟， 排序 3. 棋盘 bfs， 判断不同颜色通过的金币变化 4. 跳房子 二分 + 单调队列优化的dp判定 2016 1. 买铅笔 简单计算 2. 回文日期 枚举 + 判定 3. 海港 队列（按人头储存） 4. 魔法阵 数学计算题 2015 1. 金币 简单数学题 2. 扫雷游戏 简单模拟 3. 求和 数学计算题 4. 推销员 greedy + priority_queue 2014 1. 比例简化 模拟 + gcd 2. 珠心算测验 简单模拟 3. 螺旋矩阵 模拟 4. 子矩阵 预处理 + dp(矩阵2维dp） 2013 1. 计数问题 简单统计 2. 表达式求值 中缀 -&gt; 后缀 -&gt; 求值（用stack） 3. 小朋友的数字 简单dp 4. 车站分级 建图 + 拓扑序 2012 1. 质因数分解 筛素数 2. 寻宝 模拟 + 统计 3. 摆花 简单2维dp 4. 文化之旅 bfs 2011 1. 数字反转 简单模拟 2. 统计单词数 字符串统计 3. 瑞士轮 sort 4. 表达式的值 中缀 -&gt; 后缀 + 简单dp 2010 1. 数字统计 简单模拟 2. 接水问题 greedy 3. 导弹拦截 sort + 判断 4. 三国游戏 简单的博弈论 ","link":"https://gzhffIThh.github.io/post/li-nian-noip-pu-ji-zu-kao-dian-fen-xi/"},{"title":"莫队（优美的暴力）","content":" 解决区间统计问题 如这题 分块 + 排序 + 统计 复杂度： $ O(nm^2) $ 思想：通过分块和排序后，减少相邻区间的移动操作次数，并在区间移动过程中进行区间中统计 例题 ： P3901 SP3267 [国家集训队]小Z的袜子 /【模板】莫队 [国家集训队]数颜色 / 维护队列 /【模板】带修莫队 ","link":"https://gzhffIThh.github.io/post/mo-dui-you-mei-de-bao-li/"},{"title":"About me...","content":"这是一位来自浙江的oier。。 近期算法学习： 最短路 最小生成树 内容： 好题的题解（题面，题意，分析思路，部分分算法，正解，code） 算法笔记（解决的问题，优化思想成型的过程，常见模型，写法注意，经典题，总结） 分类（字符串，图论，数据结构，动态规划，数学，搜索，常用技巧） 记录比赛和练习 学习计划 学习蓝书上图论部分 参赛 2018noip pj初赛73 2019csp-j/s 初赛94/78.5 2019csp-j/s 复赛265/126 我的代码仓库 this ","link":"https://gzhffIThh.github.io/post/about-me/"},{"title":"树的应用","content":"重心： 定义 在一棵树中，删去一个点后，树分成的子树中最大的子树最小的一个点 性质： 无边权的树中，其他所有点到重心的距离和最小 用一条边连接两棵树，新的重心在原来两个重心的路径上 一棵树删一个点，重心最多只会移动一个位置 一棵树最多有两个重心且相邻 例题： POJ1655 POJ3107 树的直径： 定义 一棵树中最长的一条链 例题 模板 code [NOI2003]逃学的小孩 [TJOI2017]城市 [APIO2010]巡逻 [SDOI2011]消防 ","link":"https://gzhffIThh.github.io/post/shu-de-ying-yong/"},{"title":"蓝书图论刷题","content":"PART 1.最短路 P1948 [USACO08JAN]电话线Telephone Lines 题目链接 解析 分层最短路 加一维最短路 code 分层最短路（Dijkstra） #include &lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int, int&gt; PII; const int MAXN = 1001 * 1001; const int MAXP = 10001 * 1001; inline int readint() { int a = 0, f = 1; char c = getchar(); while(c &gt; '9' || c &lt; '0') { if(c == '-') f = -1; c = getchar(); } while(c &gt;= '0' &amp;&amp; c &lt;= '9') { a = a * 10 + c - '0'; c = getchar(); } return a * f; } int n, p, k; int head[MAXN], nxt[MAXP], v[MAXP], w[MAXP], cnt; int dis[MAXN], used[MAXN]; void add(int x, int y, int z) { nxt[++cnt] = head[x]; head[x] = cnt; v[cnt] = y; w[cnt] = z; } int Dijkstra() { memset(dis, 0x3f, sizeof dis); priority_queue&lt;PII, vector&lt;PII &gt;, greater&lt;PII &gt; &gt; heap; heap.push({0, 1}); dis[1] = 0; while(!heap.empty()) { while(used[heap.top().second]) heap.pop(); int u = heap.top().second; heap.pop(); used[u] = 1; for (int i = head[u]; i; i = nxt[i]) { int z = max(w[i], dis[u]); if(dis[v[i]] &gt; z) { dis[v[i]] = z; heap.push({dis[v[i]], v[i]}); } } if(u == (k + 1) * n) return dis[u]; } if(dis[(k + 1) * n] == 1061109567) return -1; return dis[(k + 1) * n]; } int main() { n = readint(), p = readint(), k = readint(); for (int i = 1; i &lt;= p; i++) { int x, y, z; x = readint(), y = readint(), z = readint(); add(x, y, z); add(y, x, z); for (int j = 1; j &lt;= k; j++)//k+1层 { add(n * (j - 1) + x, n * j + y, 0); add(n * (j - 1) + y, n * j + x, 0); add(n * j + x, n * j + y, z); add(n * j + y, n * j + x, z); } } for (int j = 1; j &lt;= k; j++) add(n * j, n * (j + 1), 0);//防止有路径小于k条边 printf(&quot;%d&quot;, Dijkstra()); return 0; } ","link":"https://gzhffIThh.github.io/post/lan-shu-tu-lun-shua-ti/"}]}